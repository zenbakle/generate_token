import os
import uuid, base64
from flask import Flask, request, jsonify
from flask_restful import Resource, Api
from flask_migrate import Migrate, MigrateCommand
from flask_sqlalchemy import SQLAlchemy
from flask_script import Manager
import random
from flask_uuid import FlaskUUID

# initializing flask app
app = Flask(__name__)
# configuring sqlalchemy and connecting connection to sqlite3
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL') or "sqlite:///token.sqlite3"
app.config['SECRET_KEY'] = '12345'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# creating database object
db = SQLAlchemy(app)

# creating migrate object
migrate = Migrate(app, db)

# creating API object
api = Api(app)

# initializing UUID
flask_uuid = FlaskUUID()
flask_uuid.init_app(app)


# creating a table name pin_table which has two columns one id which is primary key and the other pin for all the unique
# that would be generated
class pin_table(db.Model):
    id = db.Column('id', db.Integer, primary_key=True)
    pin = db.Column(db.String(15), unique=True, nullable=False)

    def __init__(self, pin):
        self.pin = pin


# the class for default resource to be returned when ever a request is made
# a pin is generated by flask uuid, which is changed into an integer by the int function
# and the back into str.the [:15] indexing takes only the first 15 string characters.
# the new code generated is saved into the database using the pin_table object.
# the newly generated pin and id is returned in json format
class Generate(Resource):
    def get(self):
        db.session.add(pin_table(str(int(uuid.uuid4()))[:15]))
        db.session.commit()
        all = pin_table.query.all()
        result = pin_table.query.filter_by(id=len(all)).first()
        id = result.id
        pin = result.pin
        return jsonify({'id': id, "pin": pin})

# resource route is defined and bounded to class generate
api.add_resource(Generate, '/')

# class for validating pin and id. the id and pin is to be validated is collected in json format and save in variables
# id and pin respectively. the database is then queried and filtered by the pin provided. the resource returned is 1 if
# a match if found andd 0 if non is found
class validate(Resource):
    def get(self):
        request_data = request.get_json()
        id = request_data['id']
        pin = request_data['pin']
        if pin_table.query.filter_by(pin=str(pin)).first() is not None:
            return "1"
        else:
            return "0"

# resource route is defined and bounded to class validate
api.add_resource(validate, '/valid')

if __name__ == '__main__':
    app.run()
